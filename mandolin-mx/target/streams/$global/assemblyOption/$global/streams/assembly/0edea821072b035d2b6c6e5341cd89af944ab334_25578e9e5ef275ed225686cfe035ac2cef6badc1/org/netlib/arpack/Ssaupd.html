<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_22) on Mon Jul 01 15:46:37 GMT-05:00 2013 -->
<TITLE>
Ssaupd
</TITLE>

<META NAME="keywords" CONTENT="org.netlib.arpack.Ssaupd class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Ssaupd";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/netlib/arpack/Ssaup2.html" title="class in org.netlib.arpack"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/netlib/arpack/Ssconv.html" title="class in org.netlib.arpack"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/netlib/arpack/Ssaupd.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Ssaupd.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.netlib.arpack</FONT>
<BR>
Class Ssaupd</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.netlib.arpack.Ssaupd</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Ssaupd</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
<pre>
Following is the description from the original
Fortran source.  For each array argument, the Java
version will include an integer offset parameter, so
the arguments may not match the description exactly.
Contact <a href="mailto:seymour@cs.utk.edu">seymour@cs.utk.edu</a> with any questions.
<p>

 *-----------------------------------------------------------------------
\BeginDoc

\Name: ssaupd

\Description: 

  Reverse communication interface for the Implicitly Restarted Arnoldi 
  Iteration.  For symmetric problems this reduces to a variant of the Lanczos 
  method.  This method has been designed to compute approximations to a 
  few eigenpairs of a linear operator OP that is real and symmetric 
  with respect to a real positive semi-definite symmetric matrix B, 
  i.e.
                   
       B*OP = (OP`)*B.  

  Another way to express this condition is 

       < x,OPy > = < OPx,y >  where < z,w > = z`Bw  .
  
  In the standard eigenproblem B is the identity matrix.  
  ( A` denotes transpose of A)

  The computed approximate eigenvalues are called Ritz values and
  the corresponding approximate eigenvectors are called Ritz vectors.

  ssaupd is usually called iteratively to solve one of the 
  following problems:

  Mode 1:  A*x = lambda*x, A symmetric 
           ===> OP = A  and  B = I.

  Mode 2:  A*x = lambda*M*x, A symmetric, M symmetric positive definite
           ===> OP = inv[M]*A  and  B = M.
           ===> (If M can be factored see remark 3 below)

  Mode 3:  K*x = lambda*M*x, K symmetric, M symmetric positive semi-definite
           ===> OP = (inv[K - sigma*M])*M  and  B = M. 
           ===> Shift-and-Invert mode

  Mode 4:  K*x = lambda*KG*x, K symmetric positive semi-definite, 
           KG symmetric indefinite
           ===> OP = (inv[K - sigma*KG])*K  and  B = K.
           ===> Buckling mode

  Mode 5:  A*x = lambda*M*x, A symmetric, M symmetric positive semi-definite
           ===> OP = inv[A - sigma*M]*[A + sigma*M]  and  B = M.
           ===> Cayley transformed mode

  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
        should be accomplished either by a direct method
        using a sparse matrix factorization and solving

           [A - sigma*M]*w = v  or M*w = v,

        or through an iterative method for solving these
        systems.  If an iterative method is used, the
        convergence test must be more stringent than
        the accuracy requirements for the eigenvalue
        approximations.

\Usage:
  call ssaupd 
     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
       IPNTR, WORKD, WORKL, LWORKL, INFO )

\Arguments
  IDO     Integer.  (INPUT/OUTPUT)
          Reverse communication flag.  IDO must be zero on the first 
          call to ssaupd.  IDO will be set internally to
          indicate the type of operation to be performed.  Control is
          then given back to the calling routine which has the
          responsibility to carry out the requested operation and call
          ssaupd with the result.  The operand is given in
          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
          (If Mode = 2 see remark 5 below)
          -------------------------------------------------------------
          IDO =  0: first call to the reverse communication interface
          IDO = -1: compute  Y = OP * X  where
                    IPNTR(1) is the pointer into WORKD for X,
                    IPNTR(2) is the pointer into WORKD for Y.
                    This is for the initialization phase to force the
                    starting vector into the range of OP.
          IDO =  1: compute  Y = OP * X where
                    IPNTR(1) is the pointer into WORKD for X,
                    IPNTR(2) is the pointer into WORKD for Y.
                    In mode 3,4 and 5, the vector B * X is already
                    available in WORKD(ipntr(3)).  It does not
                    need to be recomputed in forming OP * X.
          IDO =  2: compute  Y = B * X  where
                    IPNTR(1) is the pointer into WORKD for X,
                    IPNTR(2) is the pointer into WORKD for Y.
          IDO =  3: compute the IPARAM(8) shifts where
                    IPNTR(11) is the pointer into WORKL for
                    placing the shifts. See remark 6 below.
          IDO = 99: done
          -------------------------------------------------------------
             
  BMAT    Character*1.  (INPUT)
          BMAT specifies the type of the matrix B that defines the
          semi-inner product for the operator OP.
          B = 'I' -> standard eigenvalue problem A*x = lambda*x
          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x

  N       Integer.  (INPUT)
          Dimension of the eigenproblem.

  WHICH   Character*2.  (INPUT)
          Specify which of the Ritz values of OP to compute.

          'LA' - compute the NEV largest (algebraic) eigenvalues.
          'SA' - compute the NEV smallest (algebraic) eigenvalues.
          'LM' - compute the NEV largest (in magnitude) eigenvalues.
          'SM' - compute the NEV smallest (in magnitude) eigenvalues. 
          'BE' - compute NEV eigenvalues, half from each end of the
                 spectrum.  When NEV is odd, compute one more from the
                 high end than from the low end.
           (see remark 1 below)

  NEV     Integer.  (INPUT)
          Number of eigenvalues of OP to be computed. 0 < NEV < N.

  TOL     Real  scalar.  (INPUT)
          Stopping criterion: the relative accuracy of the Ritz value 
          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I)).
          If TOL .LE. 0. is passed a default is set:
          DEFAULT = SLAMCH('EPS')  (machine precision as computed
                    by the LAPACK auxiliary subroutine SLAMCH).

  RESID   Real  array of length N.  (INPUT/OUTPUT)
          On INPUT: 
          If INFO .EQ. 0, a random initial residual vector is used.
          If INFO .NE. 0, RESID contains the initial residual vector,
                          possibly from a previous run.
          On OUTPUT:
          RESID contains the final residual vector. 

  NCV     Integer.  (INPUT)
          Number of columns of the matrix V (less than or equal to N).
          This will indicate how many Lanczos vectors are generated 
          at each iteration.  After the startup phase in which NEV 
          Lanczos vectors are generated, the algorithm generates 
          NCV-NEV Lanczos vectors at each subsequent update iteration.
          Most of the cost in generating each Lanczos vector is in the 
          matrix-vector product OP*x. (See remark 4 below).

  V       Real  N by NCV array.  (OUTPUT)
          The NCV columns of V contain the Lanczos basis vectors.

  LDV     Integer.  (INPUT)
          Leading dimension of V exactly as declared in the calling
          program.

  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
          The shifts selected at each iteration are used to restart
          the Arnoldi iteration in an implicit fashion.
          -------------------------------------------------------------
          ISHIFT = 0: the shifts are provided by the user via
                      reverse communication.  The NCV eigenvalues of
                      the current tridiagonal matrix T are returned in
                      the part of WORKL array corresponding to RITZ.
                      See remark 6 below.
          ISHIFT = 1: exact shifts with respect to the reduced 
                      tridiagonal matrix T.  This is equivalent to 
                      restarting the iteration with a starting vector 
                      that is a linear combination of Ritz vectors 
                      associated with the "wanted" Ritz values.
          -------------------------------------------------------------

          IPARAM(2) = LEVEC
          No longer referenced. See remark 2 below.

          IPARAM(3) = MXITER
          On INPUT:  maximum number of Arnoldi update iterations allowed. 
          On OUTPUT: actual number of Arnoldi update iterations taken. 

          IPARAM(4) = NB: blocksize to be used in the recurrence.
          The code currently works only for NB = 1.

          IPARAM(5) = NCONV: number of "converged" Ritz values.
          This represents the number of Ritz values that satisfy
          the convergence criterion.

          IPARAM(6) = IUPD
          No longer referenced. Implicit restarting is ALWAYS used. 

          IPARAM(7) = MODE
          On INPUT determines what type of eigenproblem is being solved.
          Must be 1,2,3,4,5; See under \Description of ssaupd for the 
          five modes available.

          IPARAM(8) = NP
          When ido = 3 and the user provides shifts through reverse
          communication (IPARAM(1)=0), ssaupd returns NP, the number
          of shifts the user is to provide. 0 < NP <=NCV-NEV. See Remark
          6 below.

          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
          OUTPUT: NUMOP  = total number of OP*x operations,
                  NUMOPB = total number of B*x operations if BMAT='G',
                  NUMREO = total number of steps of re-orthogonalization.        

  IPNTR   Integer array of length 11.  (OUTPUT)
          Pointer to mark the starting locations in the WORKD and WORKL
          arrays for matrices/vectors used by the Lanczos iteration.
          -------------------------------------------------------------
          IPNTR(1): pointer to the current operand vector X in WORKD.
          IPNTR(2): pointer to the current result vector Y in WORKD.
          IPNTR(3): pointer to the vector B * X in WORKD when used in 
                    the shift-and-invert mode.
          IPNTR(4): pointer to the next available location in WORKL
                    that is untouched by the program.
          IPNTR(5): pointer to the NCV by 2 tridiagonal matrix T in WORKL.
          IPNTR(6): pointer to the NCV RITZ values array in WORKL.
          IPNTR(7): pointer to the Ritz estimates in array WORKL associated
                    with the Ritz values located in RITZ in WORKL.
          IPNTR(11): pointer to the NP shifts in WORKL. See Remark 6 below.

          Note: IPNTR(8:10) is only referenced by sseupd. See Remark 2.
          IPNTR(8): pointer to the NCV RITZ values of the original system.
          IPNTR(9): pointer to the NCV corresponding error bounds.
          IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors
                     of the tridiagonal matrix T. Only referenced by
                     sseupd if RVEC = .TRUE. See Remarks.
          -------------------------------------------------------------
          
  WORKD   Real  work array of length 3*N.  (REVERSE COMMUNICATION)
          Distributed array to be used in the basic Arnoldi iteration
          for reverse communication.  The user should not use WORKD 
          as temporary workspace during the iteration. Upon termination
          WORKD(1:N) contains B*RESID(1:N). If the Ritz vectors are desired
          subroutine sseupd uses this output.
          See Data Distribution Note below.  

  WORKL   Real  work array of length LWORKL.  (OUTPUT/WORKSPACE)
          Private (replicated) array on each PE or array allocated on
          the front end.  See Data Distribution Note below.

  LWORKL  Integer.  (INPUT)
          LWORKL must be at least NCV**2 + 8*NCV .

  INFO    Integer.  (INPUT/OUTPUT)
          If INFO .EQ. 0, a randomly initial residual vector is used.
          If INFO .NE. 0, RESID contains the initial residual vector,
                          possibly from a previous run.
          Error flag on output.
          =  0: Normal exit.
          =  1: Maximum number of iterations taken.
                All possible eigenvalues of OP has been found. IPARAM(5)  
                returns the number of wanted converged Ritz values.
          =  2: No longer an informational error. Deprecated starting
                with release 2 of ARPACK.
          =  3: No shifts could be applied during a cycle of the 
                Implicitly restarted Arnoldi iteration. One possibility 
                is to increase the size of NCV relative to NEV. 
                See remark 4 below.
          = -1: N must be positive.
          = -2: NEV must be positive.
          = -3: NCV must be greater than NEV and less than or equal to N.
          = -4: The maximum number of Arnoldi update iterations allowed
                must be greater than zero.
          = -5: WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.
          = -6: BMAT must be one of 'I' or 'G'.
          = -7: Length of private work array WORKL is not sufficient.
          = -8: Error return from trid. eigenvalue calculation;
                Informatinal error from LAPACK routine ssteqr.
          = -9: Starting vector is zero.
          = -10: IPARAM(7) must be 1,2,3,4,5.
          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatable.
          = -12: IPARAM(1) must be equal to 0 or 1.
          = -13: NEV and WHICH = 'BE' are incompatable.
          = -9999: Could not build an Arnoldi factorization.
                   IPARAM(5) returns the size of the current Arnoldi
                   factorization. The user is advised to check that
                   enough workspace and array storage has been allocated.


\Remarks
  1. The converged Ritz values are always returned in ascending 
     algebraic order.  The computed Ritz values are approximate
     eigenvalues of OP.  The selection of WHICH should be made
     with this in mind when Mode = 3,4,5.  After convergence, 
     approximate eigenvalues of the original problem may be obtained 
     with the ARPACK subroutine sseupd. 

  2. If the Ritz vectors corresponding to the converged Ritz values
     are needed, the user must call sseupd immediately following completion
     of ssaupd. This is new starting with version 2.1 of ARPACK.

  3. If M can be factored into a Cholesky factorization M = LL`
     then Mode = 2 should not be selected.  Instead one should use
     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular 
     linear systems should be solved with L and L` rather
     than computing inverses.  After convergence, an approximate
     eigenvector z of the original problem is recovered by solving
     L`z = x  where x is a Ritz vector of OP.

  4. At present there is no a-priori analysis to guide the selection
     of NCV relative to NEV.  The only formal requrement is that NCV > NEV.
     However, it is recommended that NCV .ge. 2*NEV.  If many problems of
     the same type are to be solved, one should experiment with increasing
     NCV while keeping NEV fixed for a given test problem.  This will 
     usually decrease the required number of OP*x operations but it
     also increases the work and storage required to maintain the orthogonal
     basis vectors.   The optimal "cross-over" with respect to CPU time
     is problem dependent and must be determined empirically.

  5. If IPARAM(7) = 2 then in the Reverse commuication interface the user
     must do the following. When IDO = 1, Y = OP * X is to be computed.
     When IPARAM(7) = 2 OP = inv(B)*A. After computing A*X the user
     must overwrite X with A*X. Y is then the solution to the linear set
     of equations B*Y = A*X.

  6. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the 
     NP = IPARAM(8) shifts in locations: 
     1   WORKL(IPNTR(11))           
     2   WORKL(IPNTR(11)+1)         
                        .           
                        .           
                        .      
     NP  WORKL(IPNTR(11)+NP-1). 

     The eigenvalues of the current tridiagonal matrix are located in 
     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1). They are in the
     order defined by WHICH. The associated Ritz estimates are located in
     WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... , WORKL(IPNTR(8)+NCV-1).

-----------------------------------------------------------------------

\Data Distribution Note:

  Fortran-D syntax:
  ================
  REAL       RESID(N), V(LDV,NCV), WORKD(3*N), WORKL(LWORKL)
  DECOMPOSE  D1(N), D2(N,NCV)
  ALIGN      RESID(I) with D1(I)
  ALIGN      V(I,J)   with D2(I,J)
  ALIGN      WORKD(I) with D1(I)     range (1:N)
  ALIGN      WORKD(I) with D1(I-N)   range (N+1:2*N)
  ALIGN      WORKD(I) with D1(I-2*N) range (2*N+1:3*N)
  DISTRIBUTE D1(BLOCK), D2(BLOCK,:)
  REPLICATED WORKL(LWORKL)

  Cray MPP syntax:
  ===============
  REAL       RESID(N), V(LDV,NCV), WORKD(N,3), WORKL(LWORKL)
  SHARED     RESID(BLOCK), V(BLOCK,:), WORKD(BLOCK,:)
  REPLICATED WORKL(LWORKL)
  

\BeginLib

\References:
  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
     pp 357-385.
  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
     Restarted Arnoldi Iteration", Rice University Technical Report
     TR95-13, Department of Computational and Applied Mathematics.
  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
     1980.
  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
     Computer Physics Communications, 53 (1989), pp 169-179.
  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
     Implement the Spectral Transformation", Math. Comp., 48 (1987),
     pp 663-673.
  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos 
     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems", 
     SIAM J. Matr. Anal. Apps.,  January (1993).
  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
     for Updating the QR decomposition", ACM TOMS, December 1990,
     Volume 16 Number 4, pp 369-377.
  8. R.B. Lehoucq, D.C. Sorensen, "Implementation of Some Spectral
     Transformations in a k-Step Arnoldi Method". In Preparation.

\Routines called:
     ssaup2  ARPACK routine that implements the Implicitly Restarted
             Arnoldi Iteration.
     sstats  ARPACK routine that initialize timing and other statistics
             variables.
     ivout   ARPACK utility routine that prints integers.
     second  ARPACK utility routine for timing.
     svout   ARPACK utility routine that prints vectors.
     slamch  LAPACK routine that determines machine constants.

\Authors
     Danny Sorensen               Phuong Vu
     Richard Lehoucq              CRPC / Rice University
     Dept. of Computational &     Houston, Texas
     Applied Mathematics
     Rice University           
     Houston, Texas            
 
\Revision history:
     12/15/93: Version ' 2.4' 

\SCCS Information: @(#) 
 FILE: saupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2 

\Remarks
     1. None

\EndLib

-----------------------------------------------------------------------

</pre>
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#bounds">bounds</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#ierr">ierr</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#ih">ih</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#iq">iq</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#ishift">ishift</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#iupd">iupd</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#iw">iw</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#ldh">ldh</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#ldq">ldq</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#mode">mode</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#msglvl">msglvl</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.netlib.util.intW</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#mxiter">mxiter</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#nb">nb</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.netlib.util.intW</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#nev0">nev0</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#next">next</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.netlib.util.intW</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#np">np</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#ritz">ritz</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.netlib.util.floatW</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#t0">t0</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.netlib.util.floatW</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#t1">t1</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#t2">t2</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#t3">t3</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#t4">t4</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#t5">t5</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#Ssaupd()">Ssaupd</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/arpack/Ssaupd.html#ssaupd(org.netlib.util.intW, java.lang.String, int, java.lang.String, int, org.netlib.util.floatW, float[], int, int, float[], int, int, int[], int, int[], int, float[], int, float[], int, int, org.netlib.util.intW)">ssaupd</A></B>(org.netlib.util.intW&nbsp;ido,
       java.lang.String&nbsp;bmat,
       int&nbsp;n,
       java.lang.String&nbsp;which,
       int&nbsp;nev,
       org.netlib.util.floatW&nbsp;tol,
       float[]&nbsp;resid,
       int&nbsp;_resid_offset,
       int&nbsp;ncv,
       float[]&nbsp;v,
       int&nbsp;_v_offset,
       int&nbsp;ldv,
       int[]&nbsp;iparam,
       int&nbsp;_iparam_offset,
       int[]&nbsp;ipntr,
       int&nbsp;_ipntr_offset,
       float[]&nbsp;workd,
       int&nbsp;_workd_offset,
       float[]&nbsp;workl,
       int&nbsp;_workl_offset,
       int&nbsp;lworkl,
       org.netlib.util.intW&nbsp;info)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="t0"><!-- --></A><H3>
t0</H3>
<PRE>
public static org.netlib.util.floatW <B>t0</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="t1"><!-- --></A><H3>
t1</H3>
<PRE>
public static org.netlib.util.floatW <B>t1</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="t2"><!-- --></A><H3>
t2</H3>
<PRE>
public static float <B>t2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="t3"><!-- --></A><H3>
t3</H3>
<PRE>
public static float <B>t3</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="t4"><!-- --></A><H3>
t4</H3>
<PRE>
public static float <B>t4</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="t5"><!-- --></A><H3>
t5</H3>
<PRE>
public static float <B>t5</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="bounds"><!-- --></A><H3>
bounds</H3>
<PRE>
public static int <B>bounds</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="ierr"><!-- --></A><H3>
ierr</H3>
<PRE>
public static int <B>ierr</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="ih"><!-- --></A><H3>
ih</H3>
<PRE>
public static int <B>ih</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="iq"><!-- --></A><H3>
iq</H3>
<PRE>
public static int <B>iq</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="ishift"><!-- --></A><H3>
ishift</H3>
<PRE>
public static int <B>ishift</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="iupd"><!-- --></A><H3>
iupd</H3>
<PRE>
public static int <B>iupd</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="iw"><!-- --></A><H3>
iw</H3>
<PRE>
public static int <B>iw</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="ldh"><!-- --></A><H3>
ldh</H3>
<PRE>
public static int <B>ldh</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="ldq"><!-- --></A><H3>
ldq</H3>
<PRE>
public static int <B>ldq</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="msglvl"><!-- --></A><H3>
msglvl</H3>
<PRE>
public static int <B>msglvl</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mxiter"><!-- --></A><H3>
mxiter</H3>
<PRE>
public static org.netlib.util.intW <B>mxiter</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mode"><!-- --></A><H3>
mode</H3>
<PRE>
public static int <B>mode</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="nb"><!-- --></A><H3>
nb</H3>
<PRE>
public static int <B>nb</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="nev0"><!-- --></A><H3>
nev0</H3>
<PRE>
public static org.netlib.util.intW <B>nev0</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="next"><!-- --></A><H3>
next</H3>
<PRE>
public static int <B>next</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="np"><!-- --></A><H3>
np</H3>
<PRE>
public static org.netlib.util.intW <B>np</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="ritz"><!-- --></A><H3>
ritz</H3>
<PRE>
public static int <B>ritz</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Ssaupd()"><!-- --></A><H3>
Ssaupd</H3>
<PRE>
public <B>Ssaupd</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ssaupd(org.netlib.util.intW, java.lang.String, int, java.lang.String, int, org.netlib.util.floatW, float[], int, int, float[], int, int, int[], int, int[], int, float[], int, float[], int, int, org.netlib.util.intW)"><!-- --></A><H3>
ssaupd</H3>
<PRE>
public static void <B>ssaupd</B>(org.netlib.util.intW&nbsp;ido,
                          java.lang.String&nbsp;bmat,
                          int&nbsp;n,
                          java.lang.String&nbsp;which,
                          int&nbsp;nev,
                          org.netlib.util.floatW&nbsp;tol,
                          float[]&nbsp;resid,
                          int&nbsp;_resid_offset,
                          int&nbsp;ncv,
                          float[]&nbsp;v,
                          int&nbsp;_v_offset,
                          int&nbsp;ldv,
                          int[]&nbsp;iparam,
                          int&nbsp;_iparam_offset,
                          int[]&nbsp;ipntr,
                          int&nbsp;_ipntr_offset,
                          float[]&nbsp;workd,
                          int&nbsp;_workd_offset,
                          float[]&nbsp;workl,
                          int&nbsp;_workl_offset,
                          int&nbsp;lworkl,
                          org.netlib.util.intW&nbsp;info)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/netlib/arpack/Ssaup2.html" title="class in org.netlib.arpack"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/netlib/arpack/Ssconv.html" title="class in org.netlib.arpack"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/netlib/arpack/Ssaupd.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Ssaupd.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
