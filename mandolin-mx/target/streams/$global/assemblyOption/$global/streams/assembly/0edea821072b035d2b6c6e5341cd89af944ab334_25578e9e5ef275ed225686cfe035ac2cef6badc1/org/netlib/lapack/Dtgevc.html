<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_22) on Mon Jul 01 15:46:35 GMT-05:00 2013 -->
<TITLE>
DTGEVC
</TITLE>

<META NAME="keywords" CONTENT="org.netlib.lapack.DTGEVC class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="DTGEVC";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/netlib/lapack/Dtgevc.html" title="class in org.netlib.lapack"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/netlib/lapack/Dtgex2.html" title="class in org.netlib.lapack"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/netlib/lapack/DTGEVC.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="DTGEVC.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.netlib.lapack</FONT>
<BR>
Class DTGEVC</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.netlib.lapack.DTGEVC</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>DTGEVC</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
<pre>
<b>DTGEVC</b> is a simplified interface to the JLAPACK routine <b>dtgevc</b>.
This interface converts Java-style 2D row-major arrays into
the 1D column-major linearized arrays expected by the lower
level JLAPACK routines.  Using this interface also allows you
to omit offset and leading dimension arguments.  However, because
of these conversions, these routines will be slower than the low
level ones.  Following is the description from the original Fortran
source.  Contact <a href="mailto:seymour@cs.utk.edu">seymour@cs.utk.edu</a> with any questions.
<p>
 *     ..
 *
 *
 *  Purpose
 *  =======
 *
 *  DTGEVC computes some or all of the right and/or left eigenvectors of

 *  a pair of real matrices (S,P), where S is a quasi-triangular matrix
 *  and P is upper triangular.  Matrix pairs of this type are produced by
 *  the generalized Schur factorization of a matrix pair (A,B):
 *
 *     A = Q*S*Z**T,  B = Q*P*Z**T
 *
 *  as computed by DGGHRD + DHGEQZ.
 *
 *  The right eigenvector x and the left eigenvector y of (S,P)
 *  corresponding to an eigenvalue w are defined by:
 *  
 *     S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
 *  
 *  where y**H denotes the conjugate tranpose of y.
 *  The eigenvalues are not input to this routine, but are computed
 *  directly from the diagonal blocks of S and P.
 *  
 *  This routine returns the matrices X and/or Y of right and left
 *  eigenvectors of (S,P), or the products Z*X and/or Q*Y,
 *  where Z and Q are input matrices.
 *  If Q and Z are the orthogonal factors from the generalized Schur
 *  factorization of a matrix pair (A,B), then Z*X and Q*Y
 *  are the matrices of right and left eigenvectors of (A,B).
 * 
 *  Arguments
 *  =========
 *
 *  SIDE    (input) CHARACTER*1
 *          = 'R': compute right eigenvectors only;
 *          = 'L': compute left eigenvectors only;
 *          = 'B': compute both right and left eigenvectors.
 *
 *  HOWMNY  (input) CHARACTER*1
 *          = 'A': compute all right and/or left eigenvectors;
 *          = 'B': compute all right and/or left eigenvectors,
 *                 backtransformed by the matrices in VR and/or VL;
 *          = 'S': compute selected right and/or left eigenvectors,
 *                 specified by the logical array SELECT.
 *
 *  SELECT  (input) LOGICAL array, dimension (N)
 *          If HOWMNY='S', SELECT specifies the eigenvectors to be
 *          computed.  If w(j) is a real eigenvalue, the corresponding
 *          real eigenvector is computed if SELECT(j) is .TRUE..
 *          If w(j) and w(j+1) are the real and imaginary parts of a
 *          complex eigenvalue, the corresponding complex eigenvector
 *          is computed if either SELECT(j) or SELECT(j+1) is .TRUE.,
 *          and on exit SELECT(j) is set to .TRUE. and SELECT(j+1) is
 *          set to .FALSE..
 *          Not referenced if HOWMNY = 'A' or 'B'.
 *
 *  N       (input) INTEGER
 *          The order of the matrices S and P.  N >= 0.
 *
 *  S       (input) DOUBLE PRECISION array, dimension (LDS,N)
 *          The upper quasi-triangular matrix S from a generalized Schur

 *          factorization, as computed by DHGEQZ.
 *
 *  LDS     (input) INTEGER
 *          The leading dimension of array S.  LDS >= max(1,N).
 *
 *  P       (input) DOUBLE PRECISION array, dimension (LDP,N)
 *          The upper triangular matrix P from a generalized Schur
 *          factorization, as computed by DHGEQZ.
 *          2-by-2 diagonal blocks of P corresponding to 2-by-2 blocks
 *          of S must be in positive diagonal form.
 *
 *  LDP     (input) INTEGER
 *          The leading dimension of array P.  LDP >= max(1,N).
 *
 *  VL      (input/output) DOUBLE PRECISION array, dimension (LDVL,MM)
 *          On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
 *          contain an N-by-N matrix Q (usually the orthogonal matrix Q
 *          of left Schur vectors returned by DHGEQZ).
 *          On exit, if SIDE = 'L' or 'B', VL contains:
 *          if HOWMNY = 'A', the matrix Y of left eigenvectors of (S,P);

 *          if HOWMNY = 'B', the matrix Q*Y;
 *          if HOWMNY = 'S', the left eigenvectors of (S,P) specified by

 *                      SELECT, stored consecutively in the columns of
 *                      VL, in the same order as their eigenvalues.
 *
 *          A complex eigenvector corresponding to a complex eigenvalue
 *          is stored in two consecutive columns, the first holding the
 *          real part, and the second the imaginary part.
 *
 *          Not referenced if SIDE = 'R'.
 *
 *  LDVL    (input) INTEGER
 *          The leading dimension of array VL.  LDVL >= 1, and if
 *          SIDE = 'L' or 'B', LDVL >= N.
 *
 *  VR      (input/output) DOUBLE PRECISION array, dimension (LDVR,MM)
 *          On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
 *          contain an N-by-N matrix Z (usually the orthogonal matrix Z
 *          of right Schur vectors returned by DHGEQZ).
 *
 *          On exit, if SIDE = 'R' or 'B', VR contains:
 *          if HOWMNY = 'A', the matrix X of right eigenvectors of (S,P);
 *          if HOWMNY = 'B' or 'b', the matrix Z*X;
 *          if HOWMNY = 'S' or 's', the right eigenvectors of (S,P)
 *                      specified by SELECT, stored consecutively in the

 *                      columns of VR, in the same order as their
 *                      eigenvalues.
 *
 *          A complex eigenvector corresponding to a complex eigenvalue
 *          is stored in two consecutive columns, the first holding the
 *          real part and the second the imaginary part.
 *          
 *          Not referenced if SIDE = 'L'.
 *
 *  LDVR    (input) INTEGER
 *          The leading dimension of the array VR.  LDVR >= 1, and if
 *          SIDE = 'R' or 'B', LDVR >= N.
 *
 *  MM      (input) INTEGER
 *          The number of columns in the arrays VL and/or VR. MM >= M.
 *
 *  M       (output) INTEGER
 *          The number of columns in the arrays VL and/or VR actually
 *          used to store the eigenvectors.  If HOWMNY = 'A' or 'B', M
 *          is set to N.  Each selected real eigenvector occupies one
 *          column and each selected complex eigenvector occupies two
 *          columns.
 *
 *  WORK    (workspace) DOUBLE PRECISION array, dimension (6*N)
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit.
 *          < 0:  if INFO = -i, the i-th argument had an illegal value.
 *          > 0:  the 2-by-2 block (INFO:INFO+1) does not have a complex

 *                eigenvalue.
 *
 *  Further Details
 *  ===============
 *
 *  Allocation of workspace:
 *  ---------- -- ---------
 *
 *     WORK( j ) = 1-norm of j-th column of A, above the diagonal
 *     WORK( N+j ) = 1-norm of j-th column of B, above the diagonal
 *     WORK( 2*N+1:3*N ) = real part of eigenvector
 *     WORK( 3*N+1:4*N ) = imaginary part of eigenvector
 *     WORK( 4*N+1:5*N ) = real part of back-transformed eigenvector
 *     WORK( 5*N+1:6*N ) = imaginary part of back-transformed eigenvector
 *
 *  Rowwise vs. columnwise solution methods:
 *  ------- --  ---------- -------- -------
 *
 *  Finding a generalized eigenvector consists basically of solving the
 *  singular triangular system
 *
 *   (A - w B) x = 0     (for right) or:   (A - w B)**H y = 0  (for left)
 *
 *  Consider finding the i-th right eigenvector (assume all eigenvalues
 *  are real). The equation to be solved is:
 *       n                   i
 *  0 = sum  C(j,k) v(k)  = sum  C(j,k) v(k)     for j = i,. . .,1
 *      k=j                 k=j
 *
 *  where  C = (A - w B)  (The components v(i+1:n) are 0.)
 *
 *  The "rowwise" method is:
 *
 *  (1)  v(i) := 1
 *  for j = i-1,. . .,1:
 *                          i
 *      (2) compute  s = - sum C(j,k) v(k)   and
 *                        k=j+1
 *
 *      (3) v(j) := s / C(j,j)
 *
 *  Step 2 is sometimes called the "dot product" step, since it is an
 *  inner product between the j-th row and the portion of the eigenvector
 *  that has been computed so far.
 *
 *  The "columnwise" method consists basically in doing the sums
 *  for all the rows in parallel.  As each v(j) is computed, the
 *  contribution of v(j) times the j-th column of C is added to the
 *  partial sums.  Since FORTRAN arrays are stored columnwise, this has
 *  the advantage that at each step, the elements of C that are accessed

 *  are adjacent to one another, whereas with the rowwise method, the
 *  elements accessed at a step are spaced LDS (and LDP) words apart.
 *
 *  When finding left eigenvectors, the matrix in question is the
 *  transpose of the one in storage, so the rowwise method then
 *  actually accesses columns of A and B at each step, and so is the
 *  preferred method.
 *
 *  =====================================================================
 *
 *     .. Parameters ..
</pre>
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/netlib/lapack/DTGEVC.html#DTGEVC()">DTGEVC</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/netlib/lapack/DTGEVC.html#DTGEVC(java.lang.String, java.lang.String, boolean[], int, double[][], double[][], double[][], double[][], int, org.netlib.util.intW, double[], org.netlib.util.intW)">DTGEVC</A></B>(java.lang.String&nbsp;side,
       java.lang.String&nbsp;howmny,
       boolean[]&nbsp;select,
       int&nbsp;n,
       double[][]&nbsp;s,
       double[][]&nbsp;p,
       double[][]&nbsp;vl,
       double[][]&nbsp;vr,
       int&nbsp;mm,
       org.netlib.util.intW&nbsp;m,
       double[]&nbsp;work,
       org.netlib.util.intW&nbsp;info)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DTGEVC()"><!-- --></A><H3>
DTGEVC</H3>
<PRE>
public <B>DTGEVC</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DTGEVC(java.lang.String, java.lang.String, boolean[], int, double[][], double[][], double[][], double[][], int, org.netlib.util.intW, double[], org.netlib.util.intW)"><!-- --></A><H3>
DTGEVC</H3>
<PRE>
public static void <B>DTGEVC</B>(java.lang.String&nbsp;side,
                          java.lang.String&nbsp;howmny,
                          boolean[]&nbsp;select,
                          int&nbsp;n,
                          double[][]&nbsp;s,
                          double[][]&nbsp;p,
                          double[][]&nbsp;vl,
                          double[][]&nbsp;vr,
                          int&nbsp;mm,
                          org.netlib.util.intW&nbsp;m,
                          double[]&nbsp;work,
                          org.netlib.util.intW&nbsp;info)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/netlib/lapack/Dtgevc.html" title="class in org.netlib.lapack"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/netlib/lapack/Dtgex2.html" title="class in org.netlib.lapack"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/netlib/lapack/DTGEVC.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="DTGEVC.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
